<!DOCTYPE html>
<html lang= "en">
    <head>
        <meta charset="UTF-8">
        <meta name = "viewport" contnet = "width=device-width,initial-scale=1.0">
     <title> Malex Assistant </title>
     
     <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
     <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!--css-->
    <script src = "https://cdn.tailwindcss.com"></script>
    
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
                'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
                sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            background-color: #f9fafb;
        }
        
        #root {
            height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .malex-header {
            background-color: white;
            border-bottom: 1px solid #e5e7eb;
            padding: 1rem 2rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
        }
        
        .malex-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            max-width: 48rem;
            margin: 0 auto;
            width: 100%;
            padding: 2rem 1rem;
        }
        
        /* Custom styles for assistant-ui components */
        .aui-root {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .aui-thread-root {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        
        .aui-thread-viewport {
            flex: 1;
            overflow-y: auto;
            padding: 1.5rem;
        }
        
        .aui-composer-root {
            border-top: 1px solid #e5e7eb;
            padding: 1rem;
            background: #f9fafb;
        }
        
        .aui-composer-input {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 1px solid #d1d5db;
            border-radius: 0.375rem;
            font-size: 1rem;
            resize: none;
            outline: none;
            transition: border-color 0.15s;
        }
        
        .aui-composer-input:focus {
            border-color: #3b82f6;
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
        }
        
        .aui-message-root {
            margin-bottom: 1.5rem;
        }
        
        .aui-message-root[data-role="assistant"] {
            background: #f3f4f6;
            padding: 1rem;
            border-radius: 0.375rem;
        }
        
        .aui-message-content {
            line-height: 1.6;
        }
        
        .connection-status {
            position: absolute;
            top: 1rem;
            right: 2rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            color: #6b7280;
        }
        
        .status-indicator {
            width: 0.5rem;
            height: 0.5rem;
            border-radius: 50%;
            background-color: #10b981;
        }
        
        .status-indicator.disconnected {
            background-color: #ef4444;
        }
        
        @keyframes bounce {
            0%, 80%, 100% {
                transform: translateY(0);
            }
            40% {
                transform: translateY(-10px);
            }
        }
        
        .animate-bounce {
            animation: bounce 1.4s infinite ease-in-out;
        }
    </style>
</head>
<body>
    <div id="root"></div>
    <script type="text/javascript">
        const{ useState , useEffect , useRef }=React;
        const {createRoot}=ReactDOM;
        
        // WebSocket connection manager
        class WebSocketRuntime {
            constructor(url) {
                this.url = url;
                this.ws = null;
                this.subscribers = new Set();
                this.connectionStatus = 'disconnected';
                this.messageQueue = [];
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 5;
                this.reconnectDelay = 1000;
            }
          

            connect(){
                if(this.ws && this.ws.readyState === Websocket.OPEN){
                return;
                }
            
                this.ws = new Websocket(this.url);

                this.ws.onopen=()=>{
                console.log('WebSocket connected');
                    this.connectionStatus = 'connected';
                    this.reconnectAttempts = 0;
                    this.notifyStatusChange();  
            }

                 while(this.messageQueue.length>0){
                    const message = this.messageQueue.shift();
                    this.ws.send(message);
                 }
                 this.ws.onmessage = (event) => {
                    try {
                        const data = JSON.parse(event.data);
                        this.notifySubscribers(data);
                    } catch (error) {
                        console.error('Failed to parse WebSocket message:', error);
                    }
                };
                
                this.ws.onclose = () => {
                    console.log('WebSocket disconnected');
                    this.connectionStatus = 'disconnected';
                    this.notifyStatusChange();
                    this.attemptReconnect();
                };
                
                this.ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                };
            }
            attemptReconnect(){
                if(this.reconnectAttempts>this.maxReconnectAttempts){
                    console.error('Cant connect max reloads done try debugging')
                    return
                }
                this.reconnectAttempts++
                const delay = this.reconnectDelay*Math.pow(2,this.reconnectAttempts-1);

                console.log(`Attempting to reconnect in ${delay}ms...`)
                setTimeout(() => this.connect(),delay);
            }
            subscribe(callback) {
                this.subscribers.add(callback);
                return () => this.subscribers.delete(callback);
            }
            
            notifySubscribers(message) {
                this.subscribers.forEach(callback => callback(message));
            }
            
            notifyStatusChange() {
                this.subscribers.forEach(callback => 
                    callback({ type: 'status', status: this.connectionStatus })
                );
            }
            send(message){
                const data = JSON.stringify({content:message});

                if(this.ws && this.ws.readyState === WebSocket.OPEN){
                    this.ws.send(data);
                }else{
                    this.messageQueue.push(data);
                    this.connect();
                }
            }
 
            function Message({ message }) {
            const isUser = message.role === 'user';
            return React.createElement('div', {
                className: `flex ${isUser ? 'justify-end' : 'justify-start'} mb-4`
            },
                React.createElement('div', {
                    className: `max-w-[70%] rounded-lg px-4 py-2 ${isUser ? 'bg-blue-500 text-white' : 'bg-gray-100 text-gray-900'}`
                },
                    React.createElement('p', { className: 'whitespace-pre-wrap' }, message.content)
                )
            );
        }

        function Chat(wsruntime){
            const [message,setMessage] = useState([]);
            const [input,setInput]= useState('');
            const [isLoading,setIsLoading]= useState(false);
            const [userScrolledUp,setUserScrolledUp]=useState(false);
            const [showScrollButton,setShowScrollButton]=useState(false);
            const messageEndRef= useRef(null);
            const messagesContainerRef= useRef(null);

            const ScrollToBottom =() =>{
                messageEndRef.current?.scrollIntoView({behavior:'smooth'});
                setShowScrollButton(false);
            }
            const handleScroll = (e) => {
                const { scrollTop, scrollHeight, clientHeight } = e.target;
                const isAtBottom = scrollHeight - scrollTop <= clientHeight + 10;
                setUserScrolledUp(!isAtBottom);
            };
        
            useEffect(() =>{
                if(messages.length>0){
                    const lastMessage = message[message.length -1];
                    if(lastMessage.role = 'user'){
                        scrollToBottom();
                        setShowScrollButton(false);
                    }else{
                        if(userScrolledUp){
                            setShowScrollButton(true);
                        }else{
                            scrollToBottom();
                        }
                    }
                }
            })
        }








    </script>
</body>


</html>